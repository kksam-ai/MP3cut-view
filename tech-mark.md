# 音频标记功能开发文档

## 功能概述

实现音频文件的标记功能，通过声音检测自动添加标记点，并支持手动调整，用于选择要导出的音频片段。系统基于声音阈值和留白时间自动检测有效音频段落，生成对应的开始(绿旗)和结束(红旗)标记。用户可以手动调整这些标记的位置，或根据需要添加、删除标记。

### 核心功能
1. 自动检测并添加标记（基于阈值和留白时间）
2. 手动调整标记（绿旗表示开始，红旗表示结束）
3. 删除标记
4. 标记列表显示和管理

## 界面设计

### 主窗口布局
- 左侧：波形显示区域（现有）
- 右侧：控制面板（新增，宽度300px）
  * 标记列表区
  * 操作按钮区

### 标记列表显示内容
- 序号（从001开始）
- 类型图标（绿旗/红旗）
- 时间点（格式：mm:ss.SSS）
- 配对状态（已配对/未配对）
- 删除按钮

### 标记样式
- 绿旗：2px绿色旗杆 + 15px向右三角形
- 红旗：2px红色旗杆 + 15px向左三角形
- 未配对标记使用半透明样式

## 交互设计

### 添加标记
1. 工具栏按钮：插入绿旗/红旗
2. 右键菜单：在点击位置插入绿旗/红旗
3. 键盘快捷键：
   - S键：插入绿旗
   - E键：插入红旗

### 移动标记
1. 鼠标拖动标记
2. 位置限制：
   - 不能越过其他标记
   - 相邻标记间隔至少1秒
   - 不能超出音频范围

### 删除标记
1. 右键菜单删除
2. 标记列表中删除按钮
3. Delete键删除选中标记

## 数据结构

### 标记对象
```typescript
interface Mark {
  id: string;           // 唯一标识
  type: 'start' | 'end';// 标记类型
  time: number;         // 时间点(秒)
  pairedId: string;     // 配对标记的ID
}
```

### 数据验证规则
1. 标记时间必须在音频范围内
2. 已配对标记间隔至少1秒
3. 允许存在未配对标记
4. 导出时处理未配对标记

## 开发阶段

### 第一阶段：基础功能
1. ✓ 实现右侧控制面板布局
2. ✓ 实现标记数据结构和管理
3. ✓ 实现自动标记功能（使用默认参数）
4. ✓ 实现标记的显示
5. ✓ 实现标记列表显示

### 第二阶段：交互优化
1. ✓ 实现标记的手动创建
2. ✓ 实现标记拖动调整
3. ✓ 实现标记删除功能
4. ✓ 实现标记列表删除
5. ✓ 实现空格键播放控制
6. [ ]实现快捷键支持（S/E/Delete）



## 技术要点

### 标记渲染
1. 使用Canvas绘制标记
2. 考虑设备像素比
3. 优化重绘性能
4. 实现标记高亮效果

### 事件处理
1. 鼠标拖动事件
2. 右键菜单事件
3. 键盘事件
4. 标记选中状态管理

### 性能优化
1. 避免频繁重绘
2. 使用请求动画帧
3. 优化数据结构
4. 减少不必要的计算

## 导出处理

### 未配对标记处理
1. 允许临时存在未配对标记
2. 导出时检查并提示
3. 提供三个选项：
   - 手动修复
   - 自动补全并导出
   - 仅导出配对标记

### 自动补全规则
1. 无结束标记的绿旗：
   - 使用下一个绿旗位置
   - 或使用音频结束位置
2. 无开始标记的红旗：
   - 使用上一个红旗位置
   - 或使用音频开始位置

## 注意事项

1. 边界情况处理
   - 音频开始和结束位置
   - 标记重叠情况
   - 快速连续操作

2. 错误处理
   - 标记创建失败
   - 位置调整无效
   - 数据验证失败

3. 性能考虑
   - 大量标记时的渲染
   - 拖动时的实时计算
   - 列表更新效率

4. 用户体验
   - 操作反馈及时
   - 错误提示友好
   - 界面响应流畅

## 标记无法显示问题的解决过程

### 问题描述
在音频波形界面上添加标记时，标记无法正常显示。

### 解决过程

### 第一次尝试
**分析**：
- 检查了标记的数据是否正确添加到了 markManager 中
- 检查了 waveformView 是否正确接收到了标记数据
- 怀疑是 CSS 布局问题导致标记被遮挡或未正确定位

**方案**：
调整了 content-area 的布局结构，使用 flex 布局：
```css
.content-area {
  flex: 1;
  position: relative;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
```

**结果**：
标记仍然无法显示，说明问题不在基础布局层面。

### 第二次尝试
**分析**：
- 发现 emptyState 可能遮挡了其他内容
- 检查了各个层级的 z-index 和定位关系

**方案**：
修改了 emptyState 的样式，确保其在未使用时完全隐藏：
```css
#emptyState {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #fff;
  z-index: 1;
}
```

**结果**：
标记依然无法显示，但确认了层级关系正确。

### 第三次尝试
**分析**：
- 检查了 loadedState 的定位方式
- 发现内部元素的定位和尺寸计算可能有问题

**方案**：
重新设计了 loadedState 及其子元素的定位方式：
```css
#loadedState {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

.playback-status-bar {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 25px;
}

.waveform-container {
  position: absolute;
  top: 25px;
  left: 0;
  right: 0;
  bottom: 25px;
  overflow-y: auto;
}

.file-status-bar {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: 25px;
}
```

**结果**：
标记终于可以正确显示了。

## 最终解决方案
问题的根本原因是内容区域的布局结构不合理，导致波形容器无法正确计算其尺寸和位置。通过以下方式解决：

1. 使用绝对定位替代了之前的 flex 布局
2. 为每个元素设置明确的位置和尺寸
3. 确保波形容器有正确的可视区域
4. 保持各个层级的合理叠放顺序

## 经验总结
1. 在处理复杂布局问题时，应该从整体架构开始检查
2. 绝对定位在某些场景下比 flex 布局更适合
3. 元素的可见性问题可能涉及多个方面：
   - 定位方式
   - 尺寸计算
   - 层级关系
   - 溢出处理
4. 应该建立清晰的布局层级结构，避免元素相互干扰
