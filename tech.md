# 音频切割软件开发记录

## 第一阶段进度

### 1. 基础框架搭建
- [x] 创建 Electron 项目结构
- [x] 配置主进程和渲染进程
- [x] 实现基础界面

### 2. 文件操作功能
- [x] 支持点击上传
- [x] 支持拖拽上传
- [x] 文件格式验证
- [x] 显示基本文件信息

### 3. 音频解析和波形显示
- [x] 音频文件转换
- [x] 波形数据计算
- [x] Canvas 波形绘制
- [x] 多行波形布局
- [x] 播放进度指示
- [x] 点击定位功能

### 4. 音频播放控制
- [x] 基础播放/暂停功能
- [x] 播放进度同步显示
- [x] 空格键播放控制
- [x] 播放结束处理
- [x] 播放位置记忆

## 遇到的问题和解决方案

### 1. FFmpeg 相关问题
**问题**: 上传文件后提示 "Cannot find ffmpeg"
**解决方案**:
- 添加 ffmpeg-static 依赖
- 设置 ffmpeg 路径
```javascript
const ffmpegPath = require('ffmpeg-static');
ffmpeg.setFfmpegPath(ffmpegPath);
```

### 2. 音频解码问题
**问题**: node-web-audio-api 解码错误 "Invalid argument, please consider using the load helper"
**解决方案**:
1. 重构音频处理架构：
   - 主进程只负责文件格式转换
   - 使用浏览器原生 Web Audio API 处理音频数据
   - 在渲染进程中计算波形

2. 处理流程优化：
   - 主进程将音频转换为 WAV 格式
   - 渲染进程读取 WAV 文件并解码
   - 使用 AudioContext 进行波形分析
   - 处理完成后删除临时文件

### 3. 波形渲染效果问题
**问题**: 长音频的波形显示不完整，细节丢失
**解决方案**:
1. 优化采样策略：
   - 移除硬编码的1000个采样点限制
   - 基于显示需求计算采样点数(每秒15个波形条)
   - 确保采样点数量与音频时长成正比

2. 改进采样算法：
   ```javascript
   const samplesNeeded = Math.ceil(
     audioBuffer.duration * (PIXELS_PER_SECOND / (BAR_WIDTH + BAR_GAP))
   );
   ```

3. 使用峰值检测：
   - 替代平均值计算
   - 保留每个时间窗口内的最大波形特征
   - 避免过度平滑和信息丢失
   ```javascript
   for (let i = 0; i < samples; i++) {
     const start = i * blockSize;
     const end = Math.min(start + blockSize, channelData.length);
     let maxAmp = 0;
     for (let j = start; j < end; j++) {
       const abs = Math.abs(channelData[j]);
       if (abs > maxAmp) maxAmp = abs;
     }
     waveform[i] = maxAmp;
   }
   ```

4. 效果验证：
   - 12分钟音频约需要10800个采样点(720秒 * 15点/秒)
   - 波形显示完整，细节清晰
   - 与短音频的渲染效果保持一致
   - 自动换行正常工作

### 4. 播放进度同步问题
**问题**: 长音频播放时波形与播放进度不同步
**解决方案**:
1. 统一时间基准：
   - 使用音频实际持续时间作为参考
   - 基于进度比例计算位置
   - 保持波形采样密度一致

2. 优化计算逻辑：
   - 移除像素级计算依赖
   - 使用波形条数索引定位
   - 添加详细日志跟踪

## 当前实现的功能
1. 文件上传
   - 支持 MP3/M4A/MP4 格式
   - 支持拖拽和点击上传
   - 文件格式验证
   - 错误处理优化

2. 音频信息显示
   - 文件名
   - 文件大小
   - 音频时长
   - 采样率

3. 波形显示
   - 实时波形计算
   - Canvas 绘制
   - 自适应窗口大小
   - 多行布局
   - 播放进度指示
   - 点击定位

4. 播放控制
   - 播放/暂停切换
   - 进度同步显示
   - 键盘快捷键
   - 播放位置记忆

## 音频元数据管理

### 1. 核心功能
- 统一的元数据结构
  * 文件基本信息管理
  * 音频参数管理
  * 标签信息管理
- 数据不可变性保证
  * 深度冻结对象
  * 防止运行时修改
  * 循环引用处理
- 完整的错误处理
  * 自定义错误类型
  * 详细错误信息
  * 错误恢复机制

### 2. 性能优化
- 对象冻结优化
  * WeakMap 缓存已冻结对象
  * 优化对象类型检查
  * 处理循环引用
- 验证优化
  * WeakSet 缓存已验证对象
  * 优化错误收集
  * 提前返回机制
- 对象创建优化
  * 减少中间对象创建
  * 优化属性访问
  * 类型检查缓存

### 3. 最佳实践
- 统一的元数据创建
- 规范的错误处理
- 安全的数据访问
- 性能优化考虑

## 下一步开发计划

### 1. 工具栏开发
- [x] 标记操作按钮
- [x] 导出功能按钮
- [x] 按钮状态管理

### 2. 波形显示优化
- [ ] 缩放比例控制
- [ ] 标记点显示
- [ ] 选区功能

### 3. 音频处理功能
- [ ] 音频剪切
- [ ] 音频导出
- [ ] 批量处理

## 技术要点总结

### 1. 进程通信
- 主进程负责文件系统操作和格式转换
- 渲染进程负责音频解析和界面交互
- 使用 IPC 进行进程间通信

### 2. 音频处理
- 使用 ffmpeg 进行格式转换
- 使用 Web Audio API 进行解码和分析
- 实现波形数据计算和归一化
- 播放进度同步机制
- 音频播放方案：
  * 使用 AudioContext 创建音频上下文
  * 通过 MediaElementSource 连接 audio 元素
  * 利用 AudioNode 管道处理音频流
  * 支持实时播放位置获取和控制

### 3. 界面实现
- 使用 Canvas 绘制波形
- 响应式设计
- 拖放操作优化
- 播放控制交互
- 设备像素比适配：
  * 使用 window.devicePixelRatio 获取设备像素比
  * Canvas 物理像素和 CSS 像素的转换
  * 确保在高分辨率屏幕下渲染清晰
  * 布局计算时考虑像素比影响
- 渲染性能优化：
  * 使用 requestAnimationFrame 进行动画
  * 避免频繁的 Canvas 状态切换
  * 合理使用缓存机制
  * 优化重绘策略

### 4. 错误处理
- 文件格式验证
- 转换过程异常处理
- 临时文件清理机制
- 用户友好的错误提示

### 5. 元数据管理
- 统一的时间格式化
  * 完整格式 (hh:mm:ss:ms)
  * 智能显示格式
  * 时间解析功能
- 数据职责划分
  * AudioBuffer 负责音频数据存储
  * 元数据模块负责信息管理
  * 确保数据一致性
- 数据获取流程
  * 从 AudioBuffer 获取原始数据
  * 通过元数据模块统一管理
  * 其他模块从元数据获取

### 6. 标记管理
- 时间精度处理
  * 使用 0.01 秒作为最小精度单位
  * 自动规范化时间值
  * 处理浮点数精度问题
- 标记冲突处理
  * 禁止新建重复标记
  * 编辑时自动偏移冲突标记
  * 支持向前向后查找可用位置

## 注意事项
1. 文件处理时需要考虑清理临时文件
2. 大文件处理需要考虑内存使用
3. 需要处理各种异常情况
4. 需要优化用户交互体验
5. 播放控制需要考虑边界情况
